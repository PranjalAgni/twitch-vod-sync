{"version":3,"sources":["utils.ts","components/VideoPicker/VideoPicker.tsx","components/Timeline/Timeline.tsx","components/Viewer/Viewer.tsx","components/VodSyncApp/VodSyncApp.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["npad","num","size","s","length","formatDate","d","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","parseDuration","m","match","Error","Number","VideoPicker","props","inputRef","handleSubmit","bind","React","createRef","evt","preventDefault","this","current","value","video","console","log","onVideoPicked","error","onSubmit","type","name","ref","placeholder","PureComponent","Timeline","videos","Array","from","values","startDate","Date","Math","min","map","v","getTime","endDate","max","duration","className","currentPosition","undefined","Viewer","interval","player","state","initialState","handleVideoPicked","updateTimestamp","setState","fetch","headers","clientId","Authorization","accessToken","response","status","json","videoInfo","data","created_at","videoDate","videoDuration","Twitch","Player","id","width","height","addEventListener","READY","PLAYING","PAUSE","window","setInterval","clearInterval","timestamp","getCurrentTime","timeline","Map","VodSyncApp","location","hash","setTimeout","href","App","Boolean","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.eea20466.chunk.js","sourcesContent":["function npad(num: number, size: number): string {\n  let s = '' + num;\n  while (s.length < size) {\n    s = '0' + s;\n  }\n  return s;\n}\n\nexport function formatDate(d: Date): string {\n  return (\n    d.getFullYear() +\n    '-' +\n    npad(d.getMonth() + 1, 2) +\n    '-' +\n    npad(d.getDate(), 2) +\n    ' ' +\n    npad(d.getHours(), 2) +\n    ':' +\n    npad(d.getMinutes(), 2) +\n    ':' +\n    npad(d.getSeconds(), 2)\n  );\n}\n\nexport function parseDuration(s: string): number {\n  const m = s.match(/(?:([0-9]+)h)?([0-9]+)m([0-9]+)s/);\n  if (!m) {\n    throw Error('Invalid duration');\n  }\n  return Number(m[1]) * 3600 + Number(m[2]) * 60 + Number(m[3]);\n}\n","import React from 'react';\n\ninterface VideoPickerProps {\n  onVideoPicked: (video: number) => void;\n}\n\nexport class VideoPicker extends React.PureComponent<VideoPickerProps> {\n  inputRef: React.RefObject<HTMLInputElement>;\n\n  constructor(props: VideoPickerProps) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.inputRef = React.createRef();\n  }\n\n  handleSubmit(evt: React.FormEvent<HTMLFormElement>) {\n    evt.preventDefault();\n    if (this.inputRef.current) {\n      const value = this.inputRef.current.value;\n      const m = value.match(\n        /^(?:https?:\\/\\/(?:www\\.|m\\.)?twitch\\.tv\\/videos\\/)?([0-9]+)$/\n      );\n      if (m) {\n        const video = Number(m[1]);\n        console.log('Picked video: ', value, ' ', video);\n        this.props.onVideoPicked(video);\n      } else {\n        console.log('Wrong URL: ', value);\n      }\n    } else {\n      console.error('No inputRef');\n    }\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input\n          type=\"text\"\n          name=\"video\"\n          ref={this.inputRef}\n          placeholder=\"Twitch video URL\"\n        />\n        <input type=\"submit\" value=\"Watch\" />\n      </form>\n    );\n  }\n}\n","import React from 'react';\nimport { formatDate } from '../../utils';\n\ninterface VideoInfo {\n  startDate: Date;\n  duration: number;\n}\n\ninterface TimelineProps {\n  videos: Map<number, VideoInfo>;\n  currentPosition?: Date;\n}\n\nexport function Timeline(props: TimelineProps) {\n  const videos = Array.from(props.videos.values());\n  const startDate = new Date(\n    Math.min(...videos.map(v => v.startDate.getTime()))\n  );\n  const endDate = new Date(\n    Math.max(...videos.map(v => v.startDate.getTime() + v.duration * 1000))\n  );\n\n  return (\n    <div className=\"timestamps\">\n      <div>{formatDate(startDate)}</div>\n      <div>\n        {props.currentPosition ? formatDate(props.currentPosition) : undefined}\n      </div>\n      <div>{formatDate(endDate)}</div>\n    </div>\n  );\n}\n","import React from 'react';\nimport { parseDuration } from '../../utils';\nimport { VideoPicker } from '../VideoPicker/VideoPicker';\nimport { Timeline } from '../Timeline/Timeline';\n\ninterface ViewerProps {\n  id: number;\n  clientId: string;\n  accessToken: string;\n}\n\ninterface ViewerState {\n  video?: number;\n  videoDate?: Date;\n  videoDuration?: number;\n  currentPosition?: Date;\n}\n\nexport class Viewer extends React.PureComponent<ViewerProps, ViewerState> {\n  interval?: number;\n  player?: Twitch.Player;\n\n  constructor(props: ViewerProps) {\n    super(props);\n    this.state = this.initialState();\n    this.interval = undefined;\n    this.player = undefined;\n    this.handleVideoPicked = this.handleVideoPicked.bind(this);\n    this.updateTimestamp = this.updateTimestamp.bind(this);\n  }\n\n  initialState() {\n    return {};\n  }\n\n  async handleVideoPicked(video: number) {\n    this.setState({ video });\n\n    // Get video information from API\n    const response = await fetch(\n      'https://api.twitch.tv/helix/videos?id=' + video,\n      {\n        headers: {\n          'Client-ID': this.props.clientId,\n          Authorization: 'Bearer ' + this.props.accessToken,\n        },\n      }\n    );\n    if (response.status === 200) {\n      const json = await response.json();\n      const videoInfo = json.data[0];\n      console.log('Got video date: ', videoInfo.created_at);\n      this.setState({\n        videoDate: new Date(videoInfo.created_at),\n        videoDuration: parseDuration(videoInfo.duration),\n      });\n    }\n\n    // Create player\n    this.player = new Twitch.Player('player' + this.props.id, {\n      width: '100%',\n      height: '100%',\n      video,\n    });\n    this.player.addEventListener(Twitch.Player.READY, this.updateTimestamp);\n    this.player.addEventListener(Twitch.Player.PLAYING, this.updateTimestamp);\n    this.player.addEventListener(Twitch.Player.PAUSE, this.updateTimestamp);\n    this.interval = window.setInterval(this.updateTimestamp, 1000);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this.interval);\n    this.interval = undefined;\n  }\n\n  updateTimestamp() {\n    if (!this.state.videoDate || !this.player) {\n      return;\n    }\n    let timestamp = this.state.videoDate.getTime();\n    timestamp += this.player.getCurrentTime() * 1000;\n    this.setState({ currentPosition: new Date(timestamp) });\n  }\n\n  render() {\n    if (this.state.video) {\n      let timeline;\n      if (this.state.videoDate && this.state.videoDuration) {\n        const videoInfo = new Map([\n          [\n            1,\n            {\n              startDate: this.state.videoDate,\n              duration: this.state.videoDuration,\n            },\n          ],\n        ]);\n        timeline = (\n          <Timeline\n            currentPosition={this.state.currentPosition}\n            videos={videoInfo}\n          />\n        );\n      }\n      return (\n        <>\n          <div id={'player' + this.props.id} className=\"player\"></div>\n          {timeline}\n        </>\n      );\n    } else {\n      return <VideoPicker onVideoPicked={this.handleVideoPicked} />;\n    }\n  }\n}\n","import React from 'react';\nimport './VodSyncApp.css';\n\nimport { Viewer } from '../Viewer/Viewer';\n\nconst TWITCH_CLIENT_ID = 'r69vc9claq1m3n960hrkuszot4nx54';\n\ninterface VodSyncAppProps {}\n\ninterface VodSyncAppState {\n  accessToken: string | null;\n}\n\nexport class VodSyncApp extends React.PureComponent<\n  VodSyncAppProps,\n  VodSyncAppState\n> {\n  constructor(props: VodSyncAppProps) {\n    super(props);\n    this.state = this.initialState();\n  }\n\n  initialState() {\n    const match = window.location.hash.match(/#access_token=([^&]+)/);\n    let accessToken = null;\n    if (match && match[1]) {\n      accessToken = match[1];\n      console.log('Got access token: ', accessToken);\n    }\n    return {\n      accessToken,\n    };\n  }\n\n  render() {\n    if (!this.state.accessToken) {\n      setTimeout(() => {\n        window.location.href =\n          'https://id.twitch.tv/oauth2/authorize?client_id=' +\n          TWITCH_CLIENT_ID +\n          '&redirect_uri=https://remram44.github.io/twitch-vod-sync/&response_type=token&scope=';\n      }, 2000);\n      return <p>Redirecting you to Twitch to authorize use of their API...</p>;\n    }\n\n    return (\n      <Viewer\n        id={1}\n        clientId={TWITCH_CLIENT_ID}\n        accessToken={this.state.accessToken}\n      />\n    );\n  }\n}\n","import React from 'react';\nimport { VodSyncApp } from './components/VodSyncApp/VodSyncApp';\n\nexport function App() {\n  return <VodSyncApp />;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ninterface Config {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('app')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}