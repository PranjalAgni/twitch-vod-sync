{"version":3,"sources":["utils.ts","components/VideoPicker/VideoPicker.tsx","components/Timeline/Timeline.tsx","components/Viewer/Viewer.tsx","components/VodSyncApp/VodSyncApp.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["npad","num","size","s","length","formatDate","d","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","parseDuration","m","match","Error","parseInt","VideoPicker","props","inputRef","handleSubmit","bind","React","createRef","evt","preventDefault","this","current","value","video","console","log","onVideoPicked","error","onSubmit","type","name","ref","placeholder","PureComponent","Timeline","videos","Array","from","values","startDate","Date","Math","min","map","v","getTime","endDate","max","duration","className","currentPosition","undefined","Viewer","interval","player","state","initialState","handleVideoPicked","updateTimestamp","setState","fetch","headers","clientId","accessToken","response","status","json","videoInfo","data","created_at","videoDate","videoDuration","Twitch","Player","id","width","height","addEventListener","READY","PLAYING","PAUSE","window","setInterval","clearInterval","timestamp","getCurrentTime","timeline","Map","VodSyncApp","location","hash","setTimeout","href","App","Boolean","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"6TAAA,SAASA,EAAKC,EAAaC,GAEzB,IADA,IAAIC,EAAI,GAAKF,EACPE,EAAEC,OAASF,GACfC,EAAI,IAAMA,EAEZ,OAAOA,EAGF,SAASE,EAAWC,GACzB,OACEA,EAAEC,cAAgB,IAChBP,EAAKM,EAAEE,WAAa,EAAG,GAAK,IAC5BR,EAAKM,EAAEG,UAAW,GAAK,IACvBT,EAAKM,EAAEI,WAAY,GAAK,IACxBV,EAAKM,EAAEK,aAAc,GAAK,IAC1BX,EAAKM,EAAEM,aAAc,GAIpB,SAASC,EAAcV,GAC5B,IAAIW,EAAKX,EAAEY,MAAM,oCACjB,IAAKD,EACH,MAAME,MAAM,oBAEd,OACmB,KAAjBC,SAASH,EAAE,IACQ,GAAjBG,SAASH,EAAE,IACXG,SAASH,EAAE,ICrBV,IAAMI,EAAb,kDAGE,WAAYC,GAA0B,IAAD,8BACnC,cAAMA,IAHRC,cAEqC,EAEnC,EAAKC,aAAe,EAAKA,aAAaC,KAAlB,gBACpB,EAAKF,SAAWG,IAAMC,YAHa,EAHvC,yDASeC,GAEX,GADAA,EAAIC,iBACDC,KAAKP,SAASQ,QAAS,CACxB,IAAIC,EAAQF,KAAKP,SAASQ,QAAQC,MAC9Bf,EAAIe,EAAMd,MAAM,gEACpB,GAAGD,EAAG,CACJ,IAAIgB,EAAQb,SAASH,EAAE,IACvBiB,QAAQC,IAAI,iBAAkBH,EAAO,IAAKC,GAC1CH,KAAKR,MAAMc,cAAcH,QAEzBC,QAAQC,IAAI,cAAeH,QAG7BE,QAAQG,MAAM,iBAtBpB,+BA2BI,OACE,0BAAMC,SAAUR,KAAKN,cACnB,2BAAOe,KAAK,OAAOC,KAAK,QAAQC,IAAKX,KAAKP,SAAUmB,YAAY,qBAChE,2BAAOH,KAAK,SAASP,MAAM,eA9BnC,GAAiCN,IAAMiB,e,OCOhC,SAASC,EAAStB,GACvB,IAAIuB,EAASC,MAAMC,KAAKzB,EAAMuB,OAAOG,UACjCC,EAAY,IAAIC,KAClBC,KAAKC,IAAL,MAAAD,KAAI,YACCN,EAAOQ,KAAI,SAAAC,GAAC,OAAIA,EAAEL,UAAUM,gBAG/BC,EAAU,IAAIN,KAChBC,KAAKM,IAAL,MAAAN,KAAI,YACCN,EAAOQ,KAAI,SAAAC,GAAC,OAAIA,EAAEL,UAAUM,UAAyB,IAAbD,EAAEI,eAIjD,OACE,yBAAKC,UAAU,cACb,6BAAMnD,EAAWyC,IACjB,6BAAM3B,EAAMsC,gBAAkBpD,EAAWc,EAAMsC,sBAAmBC,GAClE,6BAAMrD,EAAWgD,KCZhB,IAAMM,EAAb,kDAIE,WAAYxC,GAAqB,IAAD,8BAC9B,cAAMA,IAJRyC,cAGgC,IAFhCC,YAEgC,EAE9B,EAAKC,MAAQ,EAAKC,eAClB,EAAKH,cAAWF,EAChB,EAAKG,YAASH,EACd,EAAKM,kBAAoB,EAAKA,kBAAkB1C,KAAvB,gBACzB,EAAK2C,gBAAkB,EAAKA,gBAAgB3C,KAArB,gBANO,EAJlC,2DAcI,MAAO,KAdX,iFAiB0BQ,GAjB1B,kFAkBIH,KAAKuC,SAAS,CAAEpC,UAlBpB,SAqByBqC,MACnB,yCAA2CrC,EAC3C,CACEsC,QAAS,CACP,YAAazC,KAAKR,MAAMkD,SACxB,cAAiB,UAAY1C,KAAKR,MAAMmD,eA1BlD,UA8B2B,OATnBC,EArBR,QA8BgBC,OA9BhB,iCA+BuBD,EAASE,OA/BhC,OA+BUA,EA/BV,OAgCUC,EAAYD,EAAKE,KAAK,GAC1B5C,QAAQC,IAAI,mBAAoB0C,EAAUE,YAC1CjD,KAAKuC,SAAS,CACZW,UAAW,IAAI9B,KAAK2B,EAAUE,YAC9BE,cAAejE,EAAc6D,EAAUnB,YApC/C,QAyCI5B,KAAKkC,OAAS,IAAIkB,OAAOC,OAAO,SAAWrD,KAAKR,MAAM8D,GAAI,CACxDC,MAAO,OACPC,OAAQ,OACRrD,MAAOA,IAETH,KAAKkC,OAAOuB,iBAAiBL,OAAOC,OAAOK,MAAO1D,KAAKsC,iBACvDtC,KAAKkC,OAAOuB,iBAAiBL,OAAOC,OAAOM,QAAS3D,KAAKsC,iBACzDtC,KAAKkC,OAAOuB,iBAAiBL,OAAOC,OAAOO,MAAO5D,KAAKsC,iBACvDtC,KAAKiC,SAAW4B,OAAOC,YAAY9D,KAAKsC,gBAAiB,KAjD7D,qJAqDIuB,OAAOE,cAAc/D,KAAKiC,UAC1BjC,KAAKiC,cAAWF,IAtDpB,wCA0DI,GAAI/B,KAAKmC,MAAMe,WAAclD,KAAKkC,OAAlC,CAGA,IAAI8B,EAAYhE,KAAKmC,MAAMe,UAAUzB,UACrCuC,GAA4C,IAA/BhE,KAAKkC,OAAO+B,iBACzBjE,KAAKuC,SAAS,CAAET,gBAAiB,IAAIV,KAAK4C,QA/D9C,+BAmEI,GAAGhE,KAAKmC,MAAMhC,MAAO,CACnB,IAAI+D,EACJ,GAAGlE,KAAKmC,MAAMe,WAAalD,KAAKmC,MAAMgB,cAAe,CACnD,IAAMJ,EAAY,IAAIoB,IAAI,CACxB,CAAC,EAAG,CACFhD,UAAWnB,KAAKmC,MAAMe,UACtBtB,SAAU5B,KAAKmC,MAAMgB,kBAGzBe,EACE,kBAACpD,EAAD,CACEgB,gBAAiB9B,KAAKmC,MAAML,gBAC5Bf,OAAQgC,IAId,OAAO,oCACL,yBAAKO,GAAI,SAAWtD,KAAKR,MAAM8D,GAAIzB,UAAU,WAC5CqC,GAGH,OAAO,kBAAC,EAAD,CAAa5D,cAAeN,KAAKqC,wBAxF9C,GAA4BzC,IAAMiB,eCLrBuD,EAAb,kDACE,WAAY5E,GAAyB,IAAD,8BAClC,cAAMA,IACD2C,MAAQ,EAAKC,eAFgB,EADtC,2DAOI,IAAIhD,EAAQyE,OAAOQ,SAASC,KAAKlF,MAAM,yBACnCuD,EAAc,KAKlB,OAJGvD,GAASA,EAAM,KAChBuD,EAAcvD,EAAM,GACpBgB,QAAQC,IAAI,qBAAsBsC,IAE7B,CACLA,iBAdN,+BAmBI,OAAI3C,KAAKmC,MAAMQ,YAWb,kBAAC,EAAD,CAAQW,GAAI,EAAGZ,SAtCI,iCAsCwBC,YAAa3C,KAAKmC,MAAMQ,eAVnE4B,YACE,WACEV,OAAOQ,SAASG,KAAO,uKAEzB,KAEK,8FA1Bb,GAAgC5E,IAAMiB,eCJvB4D,MANf,WACE,OACE,kBAAC,EAAD,OCOgBC,QACW,cAA7Bb,OAAOQ,SAASM,UAEe,UAA7Bd,OAAOQ,SAASM,UAEhBd,OAAOQ,SAASM,SAASvF,MACvB,2DCZNwF,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,QDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAhF,GACLH,QAAQG,MAAMA,EAAMiF,c","file":"static/js/main.1a643b84.chunk.js","sourcesContent":["function npad(num: number, size: number): string {\n  var s = \"\" + num;\n  while(s.length < size) {\n    s = \"0\" + s;\n  }\n  return s;\n}\n\nexport function formatDate(d: Date): string {\n  return (\n    d.getFullYear() + \"-\"\n    + npad(d.getMonth() + 1, 2) + \"-\"\n    + npad(d.getDate(), 2) + \" \"\n    + npad(d.getHours(), 2) + \":\"\n    + npad(d.getMinutes(), 2) + \":\"\n    + npad(d.getSeconds(), 2)\n  );\n}\n\nexport function parseDuration(s: string): number {\n  var m =  s.match(/(?:([0-9]+)h)?([0-9]+)m([0-9]+)s/);\n  if (!m) {\n    throw Error(\"Invalid duration\");\n  }\n  return (\n    parseInt(m[1]) * 3600\n    + parseInt(m[2]) * 60\n    + parseInt(m[3])\n  );\n}\n","import React from 'react';\n\ninterface VideoPickerProps {\n  onVideoPicked: (video: number) => void;\n}\n\nexport class VideoPicker extends React.PureComponent<VideoPickerProps> {\n  inputRef: React.RefObject<HTMLInputElement>;\n\n  constructor(props: VideoPickerProps) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.inputRef = React.createRef();\n  }\n\n  handleSubmit(evt: React.FormEvent<HTMLFormElement>) {\n    evt.preventDefault();\n    if(this.inputRef.current) {\n      let value = this.inputRef.current.value;\n      let m = value.match(/^(?:https?:\\/\\/(?:www\\.|m\\.)?twitch\\.tv\\/videos\\/)?([0-9]+)$/);\n      if(m) {\n        let video = parseInt(m[1]);\n        console.log(\"Picked video: \", value, \" \", video);\n        this.props.onVideoPicked(video);\n      } else {\n        console.log(\"Wrong URL: \", value);\n      }\n    } else {\n      console.error(\"No inputRef\");\n    }\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <input type=\"text\" name=\"video\" ref={this.inputRef} placeholder=\"Twitch video URL\" />\n        <input type=\"submit\" value=\"Watch\" />\n      </form>\n    );\n  }\n}\n","import React from 'react';\nimport { formatDate } from '../../utils';\n\ninterface VideoInfo {\n  startDate: Date;\n  duration: number;\n}\n\ninterface TimelineProps {\n  videos: Map<number, VideoInfo>;\n  currentPosition?: Date;\n}\n\nexport function Timeline(props: TimelineProps) {\n  let videos = Array.from(props.videos.values());\n  let startDate = new Date(\n    Math.min(\n      ...videos.map(v => v.startDate.getTime())\n    )\n  );\n  let endDate = new Date(\n    Math.max(\n      ...videos.map(v => v.startDate.getTime() + v.duration * 1000)\n    )\n  );\n\n  return (\n    <div className=\"timestamps\">\n      <div>{formatDate(startDate)}</div>\n      <div>{props.currentPosition ? formatDate(props.currentPosition) : undefined}</div>\n      <div>{formatDate(endDate)}</div>\n    </div>\n  );\n}\n","import React from 'react';\nimport { parseDuration } from '../../utils';\nimport { VideoPicker } from '../VideoPicker/VideoPicker';\nimport { Timeline } from '../Timeline/Timeline';\n\ninterface ViewerProps {\n  id: number;\n  clientId: string;\n  accessToken: string;\n}\n\ninterface ViewerState {\n  video?: number;\n  videoDate?: Date;\n  videoDuration?: number;\n  currentPosition?: Date;\n}\n\nexport class Viewer extends React.PureComponent<ViewerProps, ViewerState> {\n  interval?: number;\n  player?: Twitch.Player;\n\n  constructor(props: ViewerProps) {\n    super(props);\n    this.state = this.initialState();\n    this.interval = undefined;\n    this.player = undefined;\n    this.handleVideoPicked = this.handleVideoPicked.bind(this);\n    this.updateTimestamp = this.updateTimestamp.bind(this);\n  }\n\n  initialState() {\n    return {};\n  }\n\n  async handleVideoPicked(video: number) {\n    this.setState({ video });\n\n    // Get video information from API\n    let response = await fetch(\n      \"https://api.twitch.tv/helix/videos?id=\" + video,\n      {\n        headers: {\n          \"Client-ID\": this.props.clientId,\n          \"Authorization\": \"Bearer \" + this.props.accessToken,\n        },\n      },\n    );\n    if(response.status === 200) {\n      let json = await response.json();\n      var videoInfo = json.data[0];\n      console.log(\"Got video date: \", videoInfo.created_at);\n      this.setState({\n        videoDate: new Date(videoInfo.created_at),\n        videoDuration: parseDuration(videoInfo.duration),\n      });\n    }\n\n    // Create player\n    this.player = new Twitch.Player(\"player\" + this.props.id, {\n      width: \"100%\",\n      height: \"100%\",\n      video: video,\n    });\n    this.player.addEventListener(Twitch.Player.READY, this.updateTimestamp);\n    this.player.addEventListener(Twitch.Player.PLAYING, this.updateTimestamp);\n    this.player.addEventListener(Twitch.Player.PAUSE, this.updateTimestamp);\n    this.interval = window.setInterval(this.updateTimestamp, 1000);\n  }\n\n  componentWillUnmount() {\n    window.clearInterval(this.interval);\n    this.interval = undefined;\n  }\n\n  updateTimestamp() {\n    if(!this.state.videoDate || !this.player) {\n      return;\n    }\n    let timestamp = this.state.videoDate.getTime();\n    timestamp += this.player.getCurrentTime() * 1000;\n    this.setState({ currentPosition: new Date(timestamp) });\n  }\n\n  render() {\n    if(this.state.video) {\n      let timeline;\n      if(this.state.videoDate && this.state.videoDuration) {\n        const videoInfo = new Map([\n          [1, {\n            startDate: this.state.videoDate,\n            duration: this.state.videoDuration,\n          }],\n        ]);\n        timeline = (\n          <Timeline\n            currentPosition={this.state.currentPosition}\n            videos={videoInfo}\n          />\n        );\n      }\n      return <>\n        <div id={\"player\" + this.props.id} className=\"player\"></div>\n        {timeline}\n      </>;\n    } else {\n      return <VideoPicker onVideoPicked={this.handleVideoPicked} />;\n    }\n  }\n}\n","import React from 'react';\nimport './VodSyncApp.css';\n\nimport { Viewer } from '../Viewer/Viewer';\n\nconst TWITCH_CLIENT_ID = 'r69vc9claq1m3n960hrkuszot4nx54';\n\ninterface VodSyncAppProps {}\n\ninterface VodSyncAppState {\n  accessToken: string | null;\n}\n\nexport class VodSyncApp extends React.PureComponent<VodSyncAppProps, VodSyncAppState> {\n  constructor(props: VodSyncAppProps) {\n    super(props);\n    this.state = this.initialState();\n  }\n\n  initialState() {\n    let match = window.location.hash.match(/#access_token=([^&]+)/);\n    let accessToken = null;\n    if(match && match[1]) {\n      accessToken = match[1];\n      console.log(\"Got access token: \", accessToken);\n    }\n    return {\n      accessToken,\n    };\n  }\n\n  render() {\n    if(!this.state.accessToken) {\n      setTimeout(\n        () => {\n          window.location.href = \"https://id.twitch.tv/oauth2/authorize?client_id=\" + TWITCH_CLIENT_ID + \"&redirect_uri=https://remram44.github.io/twitch-vod-sync/&response_type=token&scope=\";\n        },\n        2000,\n      );\n      return <p>Redirecting you to Twitch to authorize use of their API...</p>;\n    }\n\n    return (\n      <Viewer id={1} clientId={TWITCH_CLIENT_ID} accessToken={this.state.accessToken} />\n    );\n  }\n}\n","import React from 'react';\nimport { VodSyncApp } from './components/VodSyncApp/VodSyncApp';\n\nfunction App() {\n  return (\n    <VodSyncApp />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('app')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}